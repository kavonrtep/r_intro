---
title: "Control Structures, Apply & Functions"
format:
  revealjs:
    self-contained: true
editor: visual
---

# Control Structures

- `if` and `else`: testing a condition and acting on it

- `for`: execute a loop a fixed number of times

- `while`: execute a loop _while_ a condition is true

- `repeat`: execute an infinite loop (must `break` out of it to stop)

- `break`: break the execution of a loop

- `next`: skip an iteration of a loop


## Control Structures: if-else

```{R}
#| echo: true
#| include: true
#| eval: false
if (<condition>) {
  # do something
} else {
  # do something else
}
```

Example:
```{r}
#| echo: true
#| include: true
number <- 15
if (number < 0) {
  print("The number is negative.")
} else {
  print("The number is 0 or positive.")
}
```

## Comparison and Logical Operators

Comparison operators: `<`, `>`, `<=`, `>=`, `==`, `!=`

```{r}
#| echo: true
#| include: true
10 < 20
10 == 10
10 != 10
```

Logical operators: AND (`&`), OR (`|`), NOT (`!`)

```{r}
#| echo: true
#| include: true
TRUE & FALSE
TRUE | FALSE
!TRUE
```

## Control Structures: for loop
For loops are used to iterate over a sequence of values.
```{R}
#| echo: true
#| include: true
#| eval: false
for (i in <sequence>) {
  <statements>
}
```
Example:
```{r}
#| echo: true
#| include: true
for (i in 1:5) {
  print(i)
}
```

## Control Structures: for loop
Using `seq_along()` to iterate over vector indices:

```{r}
#| echo: true
#| include: true
num_vector <- c(2, 4, 6, 8, 10)
squares <- numeric(length(num_vector))
for (i in seq_along(num_vector)) {
  squares[i] <- num_vector[i]^2
}
print(squares)
```

## Nested loops
```{r}
#| echo: true
#| include: true
mat <- matrix(1:6, nrow = 3)
print(mat)
for (i in seq_len(nrow(mat))) {
  for (j in seq_len(ncol(mat))) {
    cat("Element [", i, ",", j, "] =", mat[i, j], "\n")
  }
}
```

## Other types of loops
- `while` loops: execute a loop while a condition is true
- `repeat` loops: execute an infinite loop
- `next` skips the current iteration
- `break` exits the loop

```{r}
#| echo: true
#| include: true
#| eval: false
while (<condition>) {
  <statements>
}

repeat {
  <statements>
  if (<condition>) break
}
```

## Vectorized operations
- R is optimized for vectorized operations
- Avoid loops when a vectorized solution exists

```{r}
#| echo: true
#| include: true
v <- c(1, 2, 3, 4, 5)
v_squared <- v^2
cat("Vectorized squares:", v_squared, "\n")
```

Loop equivalent (less efficient):

```{r}
#| echo: true
#| include: true
v_squared_loop <- numeric(length(v))
for (i in seq_along(v)) {
  v_squared_loop[i] <- v[i]^2
}
cat("Loop computed squares:", v_squared_loop, "\n")
```

## Exercise: CpG Island Detection

CpG dinucleotides are depleted in most of the genome (methylation → deamination)
but **CpG islands** near gene promoters are protected.

**Task:** Scan a 10,000 bp DNA sequence with a sliding window, count CpG
dinucleotides, and plot the result.

## Exercise: Tools you will need

```{r}
#| echo: true
#| include: true
library(stringi)
dna_sequence <- readRDS("../data/dna_sequence.rds")
```

Extract a window with `substr()`:
```{r}
#| echo: true
#| include: true
substr(dna_sequence, 1, 20)
```

Count "CG" in a string with `stri_count_fixed()`:
```{r}
#| echo: true
#| include: true
stri_count_fixed("AACGTTCGCG", "CG")
```

## Exercise: Your task

Everything is set up for you — write the **for loop**:

```{r}
#| echo: true
#| include: true
#| eval: false
window_size <- 100
n_windows <- nchar(dna_sequence) - window_size + 1
cpg_counts <- numeric(n_windows)

for (i in 1:n_windows) {
  window <- substr(dna_sequence, ?, ?)
  cpg_counts[i] <- stri_count_fixed(?, ?)
}

plot(cpg_counts, type = "l",
     xlab = "Position (bp)",
     ylab = "CpG count (per 100 bp)",
     main = "CpG Island Detection",
     col = "darkblue")
abline(h = mean(cpg_counts), col = "red", lty = 2)
```

## Apply family of functions

- `apply()`, `lapply()`, `sapply()`, `tapply()`, `mapply()`
- Apply a function to elements of a vector, list, or matrix
- More concise and often faster than explicit loops

```{r}
#| echo: true
#| include: true
#| eval: false
apply(<matrix>, <MARGIN>, <function>)  # rows (1) or columns (2)
lapply(<list>, <function>)             # returns list
sapply(<list>, <function>)             # returns vector/matrix
tapply(<vector>, <groups>, <function>) # by group
mapply(<function>, <arg1>, <arg2>)     # multiple arguments
```

## `apply`

- Apply a function to the rows or columns of a matrix
- `MARGIN = 1` for rows, `MARGIN = 2` for columns

```{r}
#| echo: true
#| include: true
set.seed(123)
mat <- matrix(rnorm(20), nrow = 5, ncol = 4)
row_means <- apply(mat, 1, mean)
cat("Row means:", row_means, "\n")
col_means <- apply(mat, 2, mean)
cat("Col means:", col_means, "\n")
```

## `lapply`

- `lapply` returns a **list** with the result of applying a function to each element

```{r}
#| echo: true
#| include: true
num_list <- list(a = 1:5, b = seq(2, 10, by = 2), c = rnorm(4))
list_means <- lapply(num_list, mean)
print(list_means)
```

## `sapply`
`sapply` is a simplified version of `lapply` that returns a vector or matrix.
```{r}
#| echo: true
#| include: true
m <- sapply(num_list, mean)
print(m)
r <- sapply(num_list, range)
print(r)
```

## `tapply`
- `tapply` applies a function to subsets of a vector defined by a grouping factor

`sample_data` data frame:
```{r}
#| echo: false
#| include: true
library(knitr)
sample_data <- read.csv("../data/sample_data.csv")
kable(head(sample_data))
```

## `tapply`
Calculate the mean of `Height` for each `Treatment` group:
```{r}
#| echo: true
#| include: true
tapply(sample_data$Height, sample_data$Treatment, mean)
```
For each level of `Treatment`, `tapply` calculates the mean of `Height`.

## `mapply`
- `mapply` is a multivariate version of `sapply`
- It applies a function to the first elements of each argument, the second elements, and so on.

```{r}
#| echo: true
#| include: true
power_func <- function(x, y) x^y
bases <- c(2, 3, 4, 5)
exponents <- c(3, 2, 2, 1)
mapply(power_func, bases, exponents)
```

## Apply on expression data

Using `apply` on real expression data:

```{r}
#| echo: true
#| include: true
#| fig-height: 3.5
feature_counts <- read.delim("../data/feature_counts.csv")
gene_totals <- apply(feature_counts, 1, sum)
hist(log10(gene_totals),
     main = "Total Expression per Gene",
     xlab = "log10(Total Expression)")
```

## Functions

- Functions are blocks of code that perform a specific task
- Functions take arguments and return a value
- Functions can be built-in, part of a package, or user-defined

```{r}
#| echo: true
#| include: true
#| eval: false
my_function <- function(x) {
   # do some stuff with x
   return(some_value)
}
```

## Functions - Example

```{r}
#| echo: true
#| include: true
my_mean <- function(x, na.rm = TRUE) {
  if (!is.numeric(x)) {
    stop("Input must be numeric.")
  }
  result <- mean(x, na.rm = na.rm)
  return(result)
}

test_vector <- c(2, 4, NA, 8, 10)
my_mean(test_vector)
```

## Functions - Default Arguments

Functions can have default arguments:

```{r}
#| echo: true
#| include: true
normalize_vector <- function(x, na.rm = TRUE) {
  if (na.rm) x <- na.omit(x)
  x_min <- min(x)
  x_max <- max(x)
  return((x - x_min) / (x_max - x_min))
}
normalize_vector(c(5, 10, 15, 20, 25))
```

## Functions with apply

Combining custom functions with `apply`:

```{r}
#| echo: true
#| include: true
normalize_expression <- function(expr_data) {
  normalized <- t(apply(expr_data, 1, normalize_vector))
  return(normalized)
}
normalized_counts <- normalize_expression(feature_counts)
head(normalized_counts[, 1:4])
```

## Functions with apply

```{r}
#| echo: true
#| include: true
#| fig-height: 4
heatmap(as.matrix(feature_counts[1:100, 1:10]))
```

## Differential Expression

```{r}
#| echo: true
#| include: true
feature_annotation <- read.delim(
  "../data/feature_annotation.csv", sep = "\t")

test_de <- function(expr_data, groups) {
  expr_data <- as.matrix(expr_data)
  means <- apply(expr_data, 1,
                 function(x) tapply(x, groups, mean))
  pval <- apply(expr_data, 1,
                function(x) t.test(x ~ groups)$p.value)
  data.frame(t(means), p_value = pval)
}

DE_results <- test_de(feature_counts,
                      feature_annotation$gender)
```

## Differential Expression - Results

```{r}
#| echo: true
#| include: true
library(knitr)
kable(head(DE_results))
```

## Volcano Plot

```{r}
#| echo: true
#| include: true
#| fig-height: 4
plot(
  log2(DE_results$male / DE_results$female),
  -log10(DE_results$p_value),
  xlab = "log2(fold change)",
  ylab = "-log10(p-value)",
  main = "Volcano Plot",
  col = "#00000060"
)
```
