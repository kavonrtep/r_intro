---
title: "RMarkdown, Quarto, and Reproducible research"
author: "Mark D. Own"
format:
   html:
      toc: true
      toc-location: left
      toc-depth: 2
      self-contained: true
editor: visual
---

# Introduction & Motivation
Reproducible research is essential for modern data science. By combining code, results, and narrative in a single document, we can ensure that analyses are transparent and automatically updated when data or methods change.

This document demonstrates:

- The basics of Quarto (the next generation of R Markdown)
- How to use code chunks and inline code
- Customizing chunk options
- Rendering documents from the command line
- Integrating tidyverse data manipulation and ggplot2 visualizations
- See [Quarto](https://quarto.org/) for more information on Quarto,
including installation instructions and a comprehensive guide to all features.
- Or [Quarto for R](https://r4ds.hadley.nz/quarto.html) for more information on using Quarto with R.

# Intended Quarto use

- Quarto is a next-generation R Markdown that is designed to be a more powerful and flexible tool for creating dynamic documents, reports, and presentations.
- Sharing your R analyses with others.
- Environment for data science and lab notebooks where you capture not only the code but also the data, results, and narrative in a single document.


# Quarto/ RMarkdown document structure

- YAML header (optionally)
  - surrounded by `---`
  - contains metadata about the document, header, author, ...
- Markdown text
    - plain text
    - contains narrative, explanations, and descriptions
    - can include formatting (headings, lists, links, images, etc.)
- Code **chunks**
  - surrounded by ` ```{r} ``` `
  - contains R code
- Inline code
  - surrounded by `r ` and backticks
  - used to include the results of R code in the text

# RStudio IDE

- Visual editor
![visual editor](./img/visual_editor.png)
- Plain text editor
![plain text editor](./img/text_editor.png)

# R Chunks
- Code chunks are used to include R code in the document.
- They are surrounded by three backticks and curly braces, like this:
- Each chunk can have options that control its behavior.
- The most used options are:
  - `#| label` : a name for the chunk (optional)
  - `#| include` : false runs the code, but doesnâ€™t show the code or results in the final document
  - `#| echo`: false prevents code, but not the results from appearing in the finished file
  - `#| eval`: whether to run the code (default: true)
  - `#| message`: whether to show messages generated by the code (default: TRUE)
  - `#| results`: hide hides printed output
  - `#| fig-show` : hide hides plots.

![chunk options](./img/chunk_options.png)
(source: [r4ds](https://r4ds.hadley.nz/quarto.html))

## Example of R chunks

```{r}
#| label: load_libraries
#| include: false
#| echo: false
# this chunk loads the libraries used in this document
# but does not show the code or results
library(tidyverse)
```
## Simple chuck with code evalated and results shown
```{r}
#| label: simple_chunk
# using default options
# this chunk runs the code and shows the results
x <- 1:10
y <- x^2
print(y)
```
## Chunk with code not evaluated
```{r}
#| label: code_not_eval
#| eval: false
# this is suitable for showing code examples
print(z)
```
## Chunk with code not show but evaluated and results shown
```{r}
#| label: code_not_show
#| echo: false
print(y)
```
# Plotting

## Simple plot with code and results shown

```{r}
#| label: plot

ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point() +
  labs(title = "Iris Sepal Length vs Width")
```
## Chunk with figure, captions and code not shown
```{r}
#| label: plot_no_code
#| fig-cap: "**Fig.1** Iris Sepal Length vs Width, by species"
#| echo: false
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  labs(title = "Iris Sepal Length vs Width")
```
## Multiple plots in one chunk
```{r}
#| label: multiple_plots
#| echo: false
plot1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point() +
  labs(title = "Iris Sepal Length vs Width")
plot2 <- ggplot(iris, aes(x = Petal.Length, y = Petal.Width, color = Species)) +
  geom_point() +
  labs(title = "Iris Petal Length vs Width")
plot1
plot2
```
## Mutiple plots side by side
```{r}
#| layout-ncol: 2
plot(1:10)
hist(rnorm(1000)^2, col=2)
hist(rnorm(1000), col=3)
```

## Inline code
- Inline code is used to include the results of R code in the text.
- It is surrounded by backticks and the letter `r`

For example, previously we created a variable `x` and assigned it the value `1:10`.
We can include the value of `x` in the text.
The value of `x` is `r x`  and the length of `x` is `r length(x)`.


# Printing tables
One of the strengths of RMarkdown and Quarto is the ability to neatly print tables
using the `kable()` function from the `knitr` package. The `kable()` function converts
a data frame (or tibble) into a simple, nicely formatted table in the final document.

## Printing without `kable`
```{r}
#| label: print_table
# print part of the iris dataset
iris[1:5, ]
```
The table above is printed without any formatting.

## Printing with `kable`
```{r}
library(knitr)
kable(iris[1:5, ])
```
## Formatting tables with `kable`
### Formating numeric columns
```{r}
# Create a sample data frame
df_example <- data.frame(
  Value = c(1234.5678, 98765.4321, 1234567.89),
  Rate  = c(0.12345, 0.98765, 0.54321)
)

# Print the table using kable()
# 'digits' sets the number of decimals,
# 'format.args' specifies formatting options for numeric values.
knitr::kable(
  df_example,
  digits = 2,
  format.args = list(big.mark = ",", decimal.mark = "."),
  caption = "Table 1: Sample Data with Formatted Numeric Columns"
)

```

### Centering columns
```{r}
# Center-align all columns by passing a vector of "c"
knitr::kable(
  df_example,
  align = rep("c", ncol(df_example)),
  caption = "Table 2: All Columns Center-Aligned"
)
```
### Different alignments
```{r}
# Left-align the first column and right-align the second column
knitr::kable(
  df_example,
  align = c("l", "r"),
  digits = 2,
  format.args = list(big.mark = ",", decimal.mark = "."),
  caption = "Table 3: Different Column Alignments"
)
```
# Cashing calculations

- Normally, every time you run a chunk, the code is executed and the results are shown.
- If the code takes a long time to run, you can use the `cache` option to save
the results of the chunk so that it doesn't have to be re-run every time.
- The cashe option can be set either in the YAML header or in the chunk options.


Yaml options:
``` yaml
---
title: "My Document"
execute:
  cache: true
---
```

- Chunk options will be applied to that chunk only

```{r}
#| label: cache_example
#| cache: true
# code with long calculation
Sys.sleep(5) # simulate a long calculation
y <- rnorm(1000)
hist(y, main = "Histogram of Random Normal Values")
```





